<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keviness&#39;s Blog</title>
  
  <subtitle>for man is man and master of his fate</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/keviness/"/>
  <updated>2020-05-02T15:07:44.015Z</updated>
  <id>https://github.com/keviness/</id>
  
  <author>
    <name>keviness</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用C语言实现贪吃蛇</title>
    <link href="https://github.com/keviness/2020/05/02/CLanguage/Clanguage_first/"/>
    <id>https://github.com/keviness/2020/05/02/CLanguage/Clanguage_first/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2020-05-02T15:07:44.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>四月份，随着考研复试的临近，毕业论文也在此刻提上了日程，我停下了手边的前端学习计划。<br>我想着在四月底实现心心念念的<a href="https://github.com/keviness/ExerciseProject/blob/master/snakes/snake2.c">贪吃蛇游戏</a>，于是就开始多线程工作啦。<br>当一个个贪吃蛇游戏的功能模块在自己手里逐步实现时，那种快乐难以描述哈。以下是一些个工作。</p><h3 id="头文件准备工作"><a href="#头文件准备工作" class="headerlink" title="头文件准备工作"></a>头文件准备工作</h3><pre><code>&lt;windows.h&gt;&lt;conio.h&gt;&lt;time.h&gt;</code></pre><p>以上这头文件需要先了解，对其中常用的API需要掌握。</p><h3 id="贪吃蛇的实现原理"><a href="#贪吃蛇的实现原理" class="headerlink" title="贪吃蛇的实现原理"></a>贪吃蛇的实现原理</h3><pre><code>struct snakes{    unsigned int len;    unsigned int speed;    unsigned int x[MAXSNAKE];    unsigned int y[MAXSNAKE];}snake;struct foods{    unsigned int x;    unsigned int y;}food;</code></pre><blockquote><ul><li>贪吃蛇的实现原理在于用结构体中的数组储存贪吃蛇的x轴与y轴的坐标。</li><li>再在相应坐标位置是打印需要的符号。</li><li>蛇的移动效果：蛇每次向前移动一个位置时，清除最后一个坐标的打印符号（” “）</li><li>蛇吃食物的增长原理：每次吃完食物后，长度加一，尾部坐标不清除其符号。</li></ul></blockquote><h3 id="各个功能的实现"><a href="#各个功能的实现" class="headerlink" title="各个功能的实现"></a>各个功能的实现</h3><p>贪吃蛇的实现主要依靠以下函数：</p><pre><code>void welcome(void);  //欢迎用户图形界面void initGraph(void);  //游戏初始化界面void createFood(void);  //随机产生食物void eatFood(void);   //当蛇吃到食物时void movingSnake(void);   //移动蛇身void controlSnake(void);   //控制蛇运动void gotoxy(int x, int y); //移动光标到对应坐标void hidenCursor(void);  //隐藏光标bool snakeStatus(void);  //判断蛇的状态</code></pre><blockquote><ul><li>其中对蛇的控制，和蛇身的移动是游戏的核心。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;四月份，随着考研复试的临近，毕业论文也在此刻提上了日程，我停下了手边的前端学习计划。&lt;br&gt;我想着在四月底实现心心念念的&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="C" scheme="https://github.com/keviness/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Date类型</title>
    <link href="https://github.com/keviness/2020/04/17/JavaScript/javascript_Date/"/>
    <id>https://github.com/keviness/2020/04/17/JavaScript/javascript_Date/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-04-17T13:26:03.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建Date对象"><a href="#创建Date对象" class="headerlink" title="创建Date对象"></a>创建Date对象</h3><pre><code>var now = new Date();   console.log(now);  //中国标准时间</code></pre><h3 id="Date解析"><a href="#Date解析" class="headerlink" title="Date解析"></a>Date解析</h3><blockquote><ul><li>Date.parse() 传入一个日期格式的字符串，该方法会返回特定的时间格式。</li></ul></blockquote><h4 id="月-日-年"><a href="#月-日-年" class="headerlink" title="月/日/年"></a>月/日/年</h4><pre><code>var date = Date.parse(&quot;06/07/2017&quot;);console.log(new Date(date));  </code></pre><h4 id="英文月名-日，年"><a href="#英文月名-日，年" class="headerlink" title="英文月名 日，年"></a>英文月名 日，年</h4><pre><code>var date = Date.parse(&quot;June 07, 2017&quot;);console.log(new Date(date));  </code></pre><hr><h3 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h3><blockquote><ul><li>接收7个参数，年，基于0的月，天，时，分，秒以及毫秒数</li></ul></blockquote><pre><code>var date = new Date(2017, 05, 06, 18, 0, 0);console.log(new Date.UTC(date)); </code></pre><h4 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h4><blockquote><ul><li>返回调用该方法时的毫秒数。</li></ul></blockquote><hr><h3 id="Date对象的格式化"><a href="#Date对象的格式化" class="headerlink" title="Date对象的格式化"></a>Date对象的格式化</h3><ul><li><p>dateObject.toLocaleString() </p><blockquote><p>按照与浏览器设置的地区相适应的格式返回日期和时间。</p></blockquote></li><li><p>dateObject.toString() </p><blockquote><p>返回带有时区的日期和时间。</p></blockquote></li><li><p>dateObject.valueOf() </p><blockquote><p>返回毫秒数</p></blockquote></li></ul><hr><h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><ul><li>toDateString() </li></ul><blockquote><ul><li>以特定于实现的格式显示星期几，月，日和年</li><li>dateObject.toDateString(); </li></ul></blockquote><ul><li>toLocaleDateString() </li></ul><blockquote><ul><li>以特定于地区的格式显示星期几，月，日和年</li><li>dateObject.toLocaleDateString();</li></ul></blockquote><ul><li>toTimeString() </li></ul><blockquote><ul><li>以特定于实现的格式显示时，分，秒和时区</li><li>dateObject.toTimeString();  </li></ul></blockquote><ul><li>toLocaleTimeString() </li></ul><blockquote><ul><li>以特定于实现的格式显示时，分，秒</li><li>dateObject.toLocaleTimeString(); </li></ul></blockquote><ul><li>toUTCString() </li></ul><blockquote><ul><li>显示完整的UTC日期</li><li>dateObject.toUTCString();</li></ul></blockquote><hr><h3 id="访问Date对象的方法"><a href="#访问Date对象的方法" class="headerlink" title="访问Date对象的方法"></a>访问Date对象的方法</h3><pre><code>dateObject.getFullYear() 获取年dateObject.getMonth() 获取月dateObject.getDate() 获取日dateObject.getHours() 获取小时dateObject.getMinutes() 获取分钟dateObject.getSeconds() 获取秒</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;创建Date对象&quot;&gt;&lt;a href=&quot;#创建Date对象&quot; class=&quot;headerlink&quot; title=&quot;创建Date对象&quot;&gt;&lt;/a&gt;创建Date对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var now = new Date();   
console.log(n
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://github.com/keviness/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 变量与作用域</title>
    <link href="https://github.com/keviness/2020/04/14/JavaScript/javascript_variable/"/>
    <id>https://github.com/keviness/2020/04/14/JavaScript/javascript_variable/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-14T14:24:20.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h3><h4 id="基本类型值："><a href="#基本类型值：" class="headerlink" title="基本类型值："></a>基本类型值：</h4><blockquote><ul><li>指那些保存在栈内存中的简单数据，即这种值完全保存在内存中的一个位置，其占据的空间大小是固定的。</li><li>基本类型的复制：基本类型在内存中占有的空间大小是固定的，复制的时候会重新在栈内存中开辟一块空间，按值来访问。 </li></ul></blockquote><h4 id="引用类型值："><a href="#引用类型值：" class="headerlink" title="引用类型值："></a>引用类型值：</h4><blockquote><ul><li>指那些保存在堆内存中的对象，这些类型的真正数据是保存在堆内存中的，而在栈内存中保存的只是一个指针，这个指针指向的是这个对象在堆内存中的地址。</li></ul></blockquote><blockquote><ul><li>引用类型的复制：引用类型所占的空间大小是不固定的，存放在堆内存中。</li><li>但内存的地址大小是固定的，故栈中存放的是对象在堆内存的地址。</li></ul></blockquote><blockquote><ul><li>查找引用类型值时，先从栈内存中取出地址，然后再到堆内存中找到对应的值，这就是引用访问。</li><li>复制时是复制的栈内存的值，只是拷贝一个引用，两个引用变量指向的堆内存中的对象是同一个对象。</li></ul></blockquote><h3 id="函数中传递参数"><a href="#函数中传递参数" class="headerlink" title="函数中传递参数"></a>函数中传递参数</h3><blockquote><ul><li>在js中参数传递都是值传递，不存在引用传递。 </li></ul></blockquote><h4 id="值类型："><a href="#值类型：" class="headerlink" title="值类型："></a>值类型：</h4><blockquote><ul><li>传递的是变量本身的值，和复制是一样的，函数中改变了变量的值，不会影响源变量值    </li></ul></blockquote><h4 id="引用类型："><a href="#引用类型：" class="headerlink" title="引用类型："></a>引用类型：</h4><blockquote><ul><li>同样是值传递，传递的是变量在栈内存空间中的地址值，如果在函数中改变了对象某一个属性的值，源变量中的值也会改变，因为在堆内存中它们是指向的同一个对象。</li></ul></blockquote><pre><code>function func(num){    num.name=123;}var box={};box.name=&apos;abcd&apos;;alert(box.name);    //abcdfunc(box);alert(box.name);    //123   值在函数func中被改变了</code></pre><h3 id="检测变量数据类型"><a href="#检测变量数据类型" class="headerlink" title="检测变量数据类型"></a>检测变量数据类型</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote><ul><li>只返回的几大基本的数据类型，在检测Object类型时则不宜使用。</li><li>Null，Object，Array，RegExp等都会返回object，那样就不知道变量到底是什么类型。    </li><li>instanceof：确定变量是哪种具体的引用类型。</li></ul></blockquote><pre><code>var box = [1,2,3]alert(box instanceof Object);　　//truealert(box instanceof Array);　　console.log(Array.isArray(box))　　//true</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><blockquote><ul><li>作用域规定了变量或者函数有权访问其他数据的权限，规定了各自的行为。    </li></ul></blockquote><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><blockquote><ul><li>在web浏览器中，全局执行环境被认为是window对象，所有的全局变量和函数都是以window对象的属性和方法创建的,</li><li>全局作用域在网页关闭或者应用程序退出后才会被销毁。</li></ul></blockquote><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><blockquote><ul><li>当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的用途是保证执行环境有权访问的所有变量和函数的有序访问。</li><li>函数体内还包含着函数，只有这个函数才可以访问内一层的函数。而内部函数的变量可以通过作用域链访问外部函数的变量，可以向上搜索作用域链，以查询变量。但是不能反过来。</li></ul></blockquote><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><blockquote><ul><li>块级作用域表示诸如if等有花括号封闭的代码段块，所以支持条件判断来定义变量。 像 if，for 等代码块中定义的变量在花括号外面是可以访问的，这和其他语言中有很大的差别。</li></ul></blockquote><pre><code>if(true){    var color = &apos;red&apos;;}console.log(color);     //red</code></pre><h4 id="var关键字在函数中的区别"><a href="#var关键字在函数中的区别" class="headerlink" title="var关键字在函数中的区别"></a>var关键字在函数中的区别</h4><blockquote><ul><li>在函数中声明变量的时候，如果不加上关键字 var 那变量会被认为是全局的，函数外面也可以访问它，当然在访问之前要先执行一次函数，加了则是局部的。</li></ul></blockquote><blockquote><ul><li>一般确定某一个变量的时候是通过搜索来确定的，现在本级作用域上找。若无，则在向上级作用域找，依次类推，故访问局部变量要比访问全局变量的效率更高。</li></ul></blockquote><h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><blockquote><ul><li>js中存在垃圾回收机制会自动的管理内存的分配和无用内存的回收。  </li><li>JS中最常用的垃圾回收的方式是标记清除，就是在运行的时候会给内存中的所有变量加上一个标记，然后去掉环境中正在使用的变量的标记。</li><li>最后垃圾清理器完成内存清理的工作，销毁那些带有标记的变量，并且回收他们所占用的内存空间 。   </li></ul></blockquote><h4 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h4><blockquote><ul><li>box = null 来释放引用，这种方式叫做删除引用，这种方式使用大多数的全局变量和全局对象。</li></ul></blockquote><blockquote><ul><li>为确保页面占用的内存更少可以让页面获得更好的性能，最好的减少内存占用量的方式就是：一旦变量或者对象不再使用的时候，将其赋值为空（null）</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本类型和引用类型的值&quot;&gt;&lt;a href=&quot;#基本类型和引用类型的值&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型的值&quot;&gt;&lt;/a&gt;基本类型和引用类型的值&lt;/h3&gt;&lt;h4 id=&quot;基本类型值：&quot;&gt;&lt;a href=&quot;#基本类型值：&quot; cla
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://github.com/keviness/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS 背景颜色</title>
    <link href="https://github.com/keviness/2020/04/11/CSS/CSS_background/"/>
    <id>https://github.com/keviness/2020/04/11/CSS/CSS_background/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-04-14T13:05:00.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h2><blockquote><p>颜色的应用主要分为前景色、背景色和透明三个部分。</p></blockquote><h3 id="前景色"><a href="#前景色" class="headerlink" title="前景色"></a>前景色</h3><blockquote><p>color | border-color</p><ul><li>值: color | inherit</li><li>初始值: 用户代理特定的值</li><li>应用于: 所有元素</li><li>继承性: 有</li><li>影响一个元素的前景色，可以使用color属性，也可以使用属性border-color设置边框颜色。</li></ul></blockquote><h3 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h3><blockquote><p>opacity</p><ul><li>opacity是CSS3中专门用来设置透明度的一个属性，opacity只能给整个元素设置一个透明度，并且其透明度直接会继承给其后代元素</li><li>值: value | inherit</li><li>value:默认值是1，可以取0-1的任意浮点数。其中，1表示完全不透明，0表示完全透明</li><li>继承性: 无</li></ul></blockquote><h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3><blockquote><ul><li>所有背景属性都不能继承</li><li>背景色background-color接受所有合法颜色，默认值是transparent。</li></ul></blockquote><pre><code>background-color: red; </code></pre><h3 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h3><blockquote><ul><li>背景图像background-image会放在所指定的背景颜色之上，初始值: none</li></ul></blockquote><pre><code>background-image: url(&quot;image/img.jpg&quot;);</code></pre><h3 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h3><blockquote><ul><li>背景平铺的属性值中space和round是CSS3新增的值。</li><li>space表示背景图像的两端对齐平铺，多出来的空间用空白代替。</li><li>round表示背景图像的两端对齐平铺，但多出来的空间通过自身拉伸来填充。</li><li>值: repeat | repeat-x | repeat-y | no-repeat | space | round | inherit</li></ul></blockquote><pre><code>background-repeat: repeat;</code></pre><h3 id="背景定位"><a href="#背景定位" class="headerlink" title="背景定位"></a>背景定位</h3><blockquote><ul><li>背景定位background-position，初始值: 0% 0%</li><li>值:  length | left | center | right | top | center | bottom </li></ul></blockquote><pre><code>background-position: center ;        background-position: 10px 20px;  </code></pre><h3 id="背景裁切"><a href="#背景裁切" class="headerlink" title="背景裁切"></a>背景裁切</h3><blockquote><ul><li>背景裁切(background-clip)属性用来定义背景图像的裁剪区域。</li><li>值：background-clip: padding-box || border-box || content-box</li></ul></blockquote><pre><code>background-clip: content-box;</code></pre><h3 id="背景尺寸"><a href="#背景尺寸" class="headerlink" title="背景尺寸"></a>背景尺寸</h3><blockquote><ul><li>使用背景尺寸(background-size)属性可以指定背景图片的尺寸，可以控制背景图片在水平和垂直两个方向的缩放。</li></ul></blockquote><pre><code>background-size: 20px 30px;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS背景&quot;&gt;&lt;a href=&quot;#CSS背景&quot; class=&quot;headerlink&quot; title=&quot;CSS背景&quot;&gt;&lt;/a&gt;CSS背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;颜色的应用主要分为前景色、背景色和透明三个部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
    
      <category term="CSS background" scheme="https://github.com/keviness/tags/CSS-background/"/>
    
  </entry>
  
  <entry>
    <title>Function Type</title>
    <link href="https://github.com/keviness/2020/04/09/JavaScript/javascript_function1/"/>
    <id>https://github.com/keviness/2020/04/09/JavaScript/javascript_function1/</id>
    <published>2020-04-08T16:00:00.000Z</published>
    <updated>2020-04-09T15:34:48.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解Function类型"><a href="#理解Function类型" class="headerlink" title="理解Function类型"></a>理解Function类型</h3><blockquote><ul><li>JS 中Function类型实际上是一种对象，每一个函数实际上都是Function类型的一个实例，函数通常是用函数声明语法定义的，而且每一个函数都有默认的属性和方法。</li><li>因为函数是一个对象，故函数名实际上也是一个指向函数对象的指针变量，不会与某个函数绑定。</li></ul></blockquote><h4 id="函数声明与表达式（匿名函数）"><a href="#函数声明与表达式（匿名函数）" class="headerlink" title="函数声明与表达式（匿名函数）"></a>函数声明与表达式（匿名函数）</h4><p>函数声明会优先被读取使用（函数可提前访问）。</p><pre><code>console.log(test(10,30))；　　//40function test(num1,num2) {    return num1+num2;};</code></pre><p>函数表达式则必须等到执行完它所在的表达行后再可以使用。</p><pre><code>console.log(test(10,30));　　//errorvar test = function (num1,num2) {    return num1+num2;};</code></pre><h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><blockquote><ul><li>js中的函数名本身就是变量，所以函数也可以作为值来使用，可以像传递参数一样把一个函数传递给另一个函数。</li></ul></blockquote><pre><code>function sum (num1, num2) {    return num1 + num2;}function fuc (num3, num4) {    return num3 + num4;}console.log(fuc(sum(2,3), 5));　　//10等同于：function sum (num1, num2) {    return num1+num2;}function func(num1){    return sum(num1,5);}alert(func(5));    //10</code></pre><hr><h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><blockquote><ul><li>在函数内部包含两个特殊的对象：arguments和this</li></ul></blockquote><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments:"></a>arguments:</h4><blockquote><ul><li>arguments 是一个类数组，用来保存函数传递过来的参数。</li><li>arguments 中还有一个很重要的属性就是callee，是一个指针变量，指向的是arguments所在的函数本身，在递归中可用这个属性，因为如果函数名改变了，也不需要改变内部的实现。</li><li>arguments.callee()始终代表的是这个函数本身. </li></ul></blockquote><pre><code>function box(num){    if(num&lt;=1){        return 1;    }else{        return num*arguments.callee(num-1);            //arguments.callee代表的是函数的本身，故和上面是同样的效果    }}alert(box(3));//6</code></pre><h4 id="this"><a href="#this" class="headerlink" title="this:"></a>this:</h4><blockquote><ul><li>this 这个属性代表的是它所在的对象本身，this 引用的是函数据以执行的环境对象，也就是函数执行的作用域。</li><li>window是JS中最大的一个对象，在window对象中声明一个变量其实就是给window这个对象声明一个属性，var box=1;相当于 window.box=1;也就等价于this.box=1;</li><li>当在全局作用域中调用函数时，this 对象引用的就是 window。</li><li>在显示的声明一个对象box，这个box中使用的this就代表的是box本身，this.color就是返回的box中属性color的值，而不是window对象中color的值</li></ul></blockquote><pre><code>var box={    color:&apos;blue&apos;,    run:function(){        alert(this.color);    //blue        return this.color;    }}alert(window.color);    //redalert(this.color);     //red 此处this代表的是window对象，故this.color是代表的window的属性alert(box.run());      //blue</code></pre><hr><h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><blockquote><p>每个函数都包含两个属性：length和prototype</p></blockquote><h4 id="length"><a href="#length" class="headerlink" title="length:"></a>length:</h4><blockquote><p>函数的属性length代表的是函数希望接收的参数的个数，是由声明函数时参数列表中的个数决定的。</p></blockquote><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype:"></a>prototype:</h4><blockquote><ul><li>prototype 是保存所有实例方法的实际所在，也就是原型。  </li><li>prototype下面有两个方法：apply()，call()，这两个方法都是函数非继承而来的方法，是每一个函数都具有的方法。</li><li>这两个方法的用途都是在特定的作用域中调用函数(看this指向的作用域是谁) </li></ul></blockquote><pre><code>function sum (num1, num2) {    return num1 + num2;}var result = sum.apply(this,[10,20]);var result = sum.call(this,10,20);console.log(result);</code></pre><blockquote><ul><li>func.apply()；方法有两个参数，第一个参数是要执行这个方法的作用域，也就是传递一个对象，第二个参数是一个数组，这个数组中是存放的调用的函数func的实参，也就是要传递给func的值，当然这个参数可以省略。  </li><li>func.call()：方法和上面的apply()方法相似，不同的是参数，作用域和apply()一样，但其余的参数是逐个列举出传递给函数的，而不是传递一个数组。</li><li>使用这apply()和call()这两个方法来扩充作用域最大的好处是：对象不需要与方法发生任何的耦合关系。</li></ul></blockquote><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h4><pre><code>var color=&apos;red&apos;;var box={    color:&apos;green&apos;}function sayColor(){    return this.color;}alert(sayColor());          　　//red 对象：windowalert(sayColor.apply(window));  //red  对象：windowalert(sayColor.apply(this));    //red  对象：windowalert(sayColor.apply(box));     //green  对象：box</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解Function类型&quot;&gt;&lt;a href=&quot;#理解Function类型&quot; class=&quot;headerlink&quot; title=&quot;理解Function类型&quot;&gt;&lt;/a&gt;理解Function类型&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;JS 中Functio
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://github.com/keviness/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTML FORM</title>
    <link href="https://github.com/keviness/2020/04/08/HtmlNote/Html_form/"/>
    <id>https://github.com/keviness/2020/04/08/HtmlNote/Html_form/</id>
    <published>2020-04-07T16:00:00.000Z</published>
    <updated>2020-05-01T14:09:08.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="表单的一些属性："><a href="#表单的一些属性：" class="headerlink" title="表单的一些属性："></a>表单的一些属性：</h3><ol><li>name属性：用于对提交到服务器后的表单数据进行标识,是一种key-value的对应形式。  </li><li>value属性：在input框里面写的值。</li><li>readonly属性：使表单元素变为只读。</li><li>disabled属性：让按钮变灰，使表单元素不可用。</li></ol><hr><h3 id="常见表单元素"><a href="#常见表单元素" class="headerlink" title="常见表单元素"></a>常见表单元素</h3><h4 id="常见表单元素应用场景"><a href="#常见表单元素应用场景" class="headerlink" title="常见表单元素应用场景"></a>常见表单元素应用场景</h4><img src="/2020/04/08/HtmlNote/Html_form/form.png" class title="FormApplication"><h4 id="代码举例："><a href="#代码举例：" class="headerlink" title="代码举例："></a>代码举例：</h4><pre><code>单行文本框&lt;input type=&quot;text&quot; name=&quot;key&quot; value=&quot;123&quot; readonly=&quot;readonly&quot; disabled=&quot;disabled&quot;/&gt;  密码框&lt;input type=&quot;password&quot;/&gt;　　下拉列表&lt;selected&gt;    &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;    &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;    &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;&lt;/selected&gt;单选框&lt;input type=&quot;radio&quot; name=&quot;like&quot; value=&quot;喜欢&quot; checked=&quot;checked&quot;/&gt;　　&lt;input type=&quot;radio&quot; name=&quot;like&quot; value=&quot;不喜欢&quot;/&gt;多选框&lt;input type=&quot;checkbox&quot; name=&quot;run&quot; value=&quot;跑&quot; checked=&quot;checked&quot;/&gt;　　&lt;input type=&quot;checkbox&quot; name=&quot;climb&quot; value=&quot;爬山&quot;/&gt;文件域&lt;input type=&quot;file&quot;&gt;多行文本框&lt;textarea rows=&quot;5&quot; cols=&quot;10&quot;&gt;&lt;/textarea&gt;提交按钮&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;　重置按钮&lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;  按钮&lt;input type=&quot;button&quot; value=&quot;按钮&quot;/&gt;  图像按钮&lt;input type=&quot;image&quot; src=&quot;img.jpg&quot;&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;表单的一些属性：&quot;&gt;&lt;a href=&quot;#表单的一些属性：&quot; class=&quot;headerlink&quot; title=&quot;表单的一些属性：&quot;&gt;&lt;/a&gt;表单的一些属性：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;name属性：用于对提交到服务器后的表单数据进行标识,是一种key-value的
      
    
    </summary>
    
    
    
      <category term="HTML" scheme="https://github.com/keviness/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>CSS样式表的引入</title>
    <link href="https://github.com/keviness/2020/04/07/CSS/CSS_Link/"/>
    <id>https://github.com/keviness/2020/04/07/CSS/CSS_Link/</id>
    <published>2020-04-06T16:00:00.000Z</published>
    <updated>2020-04-08T15:01:09.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="css样式表的引入"><a href="#css样式表的引入" class="headerlink" title="css样式表的引入"></a>css样式表的引入</h2><h3 id="内嵌样式表"><a href="#内嵌样式表" class="headerlink" title="内嵌样式表"></a>内嵌样式表</h3><blockquote><p>内嵌样式表是写在Tag(标签)里面的。内嵌样式只对所在的Tag有效 (若有多种样式，内嵌式会覆盖其它的样式)。</p></blockquote><pre><code>&lt;p style=&quot;font-size:20px; color:red&quot;&gt;&lt;/p&gt;</code></pre><blockquote><p>这个style定义p标签里面的文字 是20px字体，字体颜色是红色。</p></blockquote><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><blockquote><p>内部样式表是写在HTML的head标签里面的，内部样式表只对所在的网页有效。<br>内部样式表要用到style标签，如下 ：</p></blockquote><pre><code>&lt;style  type=&quot;text/css&quot;&gt;    div{        color : red;    }&lt;/style&gt;</code></pre><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><blockquote><p>若很多网页需要用到同样的样式，此时需要用外部样式表。<br>外部样式表需要将样式写在一个css文件中,然后在页面中用link标签引入，在需要应用该样式的每个页面中引入该文件。<br>rel=”stylesheet” type=”text/css” 是固定写法不可修改。</p></blockquote><pre><code>&lt;html&gt;&lt;head&gt;    &lt;link href=&quot;./css/example.css &quot; rel =&quot;stylesheet&quot; type=&quot;text/css &quot;&gt;&lt;/head&gt;&lt;body&gt;…&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;css样式表的引入&quot;&gt;&lt;a href=&quot;#css样式表的引入&quot; class=&quot;headerlink&quot; title=&quot;css样式表的引入&quot;&gt;&lt;/a&gt;css样式表的引入&lt;/h2&gt;&lt;h3 id=&quot;内嵌样式表&quot;&gt;&lt;a href=&quot;#内嵌样式表&quot; class=&quot;header
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://github.com/keviness/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 常见对齐方式</title>
    <link href="https://github.com/keviness/2020/04/02/CSS/CSS_align/"/>
    <id>https://github.com/keviness/2020/04/02/CSS/CSS_align/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2020-04-06T14:01:55.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS-水平居中"><a href="#CSS-水平居中" class="headerlink" title="CSS 水平居中"></a>CSS 水平居中</h3><h4 id="若子元素为行内元素（inline）"><a href="#若子元素为行内元素（inline）" class="headerlink" title="若子元素为行内元素（inline）"></a>若子元素为行内元素（inline）</h4><pre><code>parentNode{    text-align:center;}</code></pre><h4 id="若子元素为块元素（block）"><a href="#若子元素为块元素（block）" class="headerlink" title="若子元素为块元素（block）"></a>若子元素为块元素（block）</h4><h5 id="宽度固定"><a href="#宽度固定" class="headerlink" title="宽度固定"></a>宽度固定</h5><pre><code>childNode{    margin:0 auto;}</code></pre><h5 id="宽度不固定"><a href="#宽度不固定" class="headerlink" title="宽度不固定"></a>宽度不固定</h5><pre><code>parentNode{    text-align:center;}childNode{    display:inline-block(inline);}</code></pre><hr><h3 id="CSS垂直居中"><a href="#CSS垂直居中" class="headerlink" title="CSS垂直居中"></a>CSS垂直居中</h3><h4 id="若子元素为行内元素（inline）-1"><a href="#若子元素为行内元素（inline）-1" class="headerlink" title="若子元素为行内元素（inline）"></a>若子元素为行内元素（inline）</h4><pre><code>parentNode{    height:A px;}childNode{    line-heght:A px;}</code></pre><h4 id="若子元素为块元素（block）-1"><a href="#若子元素为块元素（block）-1" class="headerlink" title="若子元素为块元素（block）"></a>若子元素为块元素（block）</h4><blockquote><p>块级元素的高度由内容撑起。</p></blockquote><h5 id="高度未定"><a href="#高度未定" class="headerlink" title="高度未定"></a>高度未定</h5><pre><code>parentNode{    display:table-cell;    vertical-align:middle;}</code></pre><h5 id="高度已定"><a href="#高度已定" class="headerlink" title="高度已定"></a>高度已定</h5><pre><code>parentNode{    height:A px;}childNode{    height:B px;    margin-top/margin-bottom:(A-B)/2px; }</code></pre><hr><h3 id="CSS垂直居中万能语法"><a href="#CSS垂直居中万能语法" class="headerlink" title="CSS垂直居中万能语法"></a>CSS垂直居中万能语法</h3><pre><code>parentNode{    position:relative;}childNode{    position:absolute;    top:50%;    left:50%;    width:Xpx;    height:Ypx;    margin-top:-(Y/2)px;    margin-left:-(X/2)px;}</code></pre><hr><h3 id="CSS水平垂直居中"><a href="#CSS水平垂直居中" class="headerlink" title="CSS水平垂直居中"></a>CSS水平垂直居中</h3><h4 id="水平对齐-行高（子元素为inline元素）"><a href="#水平对齐-行高（子元素为inline元素）" class="headerlink" title="水平对齐+行高（子元素为inline元素）"></a>水平对齐+行高（子元素为inline元素）</h4><pre><code>parentNode{    height:A px;    text-align:center;}childNode{    line-height:A px;}</code></pre><h4 id="水平对齐-垂直对齐（子元素为block元素）"><a href="#水平对齐-垂直对齐（子元素为block元素）" class="headerlink" title="水平对齐+垂直对齐（子元素为block元素）"></a>水平对齐+垂直对齐（子元素为block元素）</h4><pre><code>parentNode{    display:table-cell;    text-align:center;    vertical-align:center;}childNode{    diaplay:inline-block;}</code></pre><h4 id="relative-absolute（任意元素）"><a href="#relative-absolute（任意元素）" class="headerlink" title="relative+absolute（任意元素）"></a>relative+absolute（任意元素）</h4><pre><code>parentNode{    position:relative;}childNode{    position:absolute;    margin:auto;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CSS-水平居中&quot;&gt;&lt;a href=&quot;#CSS-水平居中&quot; class=&quot;headerlink&quot; title=&quot;CSS 水平居中&quot;&gt;&lt;/a&gt;CSS 水平居中&lt;/h3&gt;&lt;h4 id=&quot;若子元素为行内元素（inline）&quot;&gt;&lt;a href=&quot;#若子元素为行内元素（in
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://github.com/keviness/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms(second)</title>
    <link href="https://github.com/keviness/2020/03/22/Algorithms/Algorithms_second/"/>
    <id>https://github.com/keviness/2020/03/22/Algorithms/Algorithms_second/</id>
    <published>2020-03-21T16:00:00.000Z</published>
    <updated>2020-04-26T07:12:52.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法（Algorithms）"><a href="#算法（Algorithms）" class="headerlink" title="算法（Algorithms）"></a>算法（Algorithms）</h2><h3 id="算法定义："><a href="#算法定义：" class="headerlink" title="算法定义："></a>算法定义：</h3><blockquote><p>算法是解决特定问题求解步骤的描述，在计算机表现为指令的有限序列，且每个指令表示一个或多个操作。</p></blockquote><hr><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><h4 id="一，输入输出："><a href="#一，输入输出：" class="headerlink" title="一，输入输出："></a>一，输入输出：</h4><ol><li>输入：算法具有零个或一个输入。</li><li>输出：算法具有至少一个输出。</li></ol><hr><h4 id="二，有穷性："><a href="#二，有穷性：" class="headerlink" title="二，有穷性："></a>二，有穷性：</h4><ol><li>算法在执行有限的步骤之后，会自动结束而不会出现无限循环，且每个步骤须在有限的时间内完成。</li></ol><hr><h4 id="三，确定性："><a href="#三，确定性：" class="headerlink" title="三，确定性："></a>三，确定性：</h4><ol><li>算法的每一个步骤都有明确的含义，不会出现二义性</li><li>一定条件下，只有一条执行路径，相同输入只能获得的一个输出结果，每个步骤被精确定义，无歧义。</li></ol><hr><h4 id="四，可行性："><a href="#四，可行性：" class="headerlink" title="四，可行性："></a>四，可行性：</h4><ol><li>算法的每一个步骤都是可执行的，每一步都可执行有限步骤完成。</li></ol><hr><h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><blockquote><p>时间复杂度：算法的时间度量。</p></blockquote><hr><h4 id="算法时间复杂度表示方法：大O阶表示方法"><a href="#算法时间复杂度表示方法：大O阶表示方法" class="headerlink" title="算法时间复杂度表示方法：大O阶表示方法"></a>算法时间复杂度表示方法：大O阶表示方法</h4><blockquote><p>T(n) = O(f(n))：随问题规模n的增大，执行时间的增长率与f(n)的增长率相同。<br>n：问题规模；f(n)：运行次数函数（基本操作数量）。</p></blockquote><ol><li>加法常数：用常数1取代。</li><li>只保留运行次数函数中的最高阶项。</li><li>若最高阶存在，且不是1，去处最高阶项常数。</li></ol><hr><h4 id="常见的算法时间复杂度表示："><a href="#常见的算法时间复杂度表示：" class="headerlink" title="常见的算法时间复杂度表示："></a>常见的算法时间复杂度表示：</h4><img src="/2020/03/22/Algorithms/Algorithms_second/Algorithms_second.png" class title="algorithms"><hr><h3 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h3><blockquote><p>计算算法所需的存储空间的实现。<br>计算公式：S(n) = O(f(n))<br>n：问题规模； f(n)：关于n所占存储空间内存的函数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法（Algorithms）&quot;&gt;&lt;a href=&quot;#算法（Algorithms）&quot; class=&quot;headerlink&quot; title=&quot;算法（Algorithms）&quot;&gt;&lt;/a&gt;算法（Algorithms）&lt;/h2&gt;&lt;h3 id=&quot;算法定义：&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
    
      <category term="Algorithms" scheme="https://github.com/keviness/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms(first)</title>
    <link href="https://github.com/keviness/2020/03/20/Algorithms/Algorithms_start/"/>
    <id>https://github.com/keviness/2020/03/20/Algorithms/Algorithms_start/</id>
    <published>2020-03-19T16:00:00.000Z</published>
    <updated>2020-04-02T14:19:59.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><blockquote><p>if you give someone a program you will frustrate him for a day, if you teach someone how to program you will frustrate him for a lifetime（如果你给了一个人一串代码，你将折磨他一整天；如果你教会他如何编程，你将折磨他一辈子。）</p></blockquote><p>&nbsp;&nbsp;<br>很荣幸，我找到了自己喜爱的事情：”frustrate myself for lifetime.”，最近在准备考研复试，在闲余时间，想着顺便把心心念念的算法过一遍，以下是一些个记录。</p><hr><h4 id="数据结构基本概念与术语"><a href="#数据结构基本概念与术语" class="headerlink" title="数据结构基本概念与术语"></a>数据结构基本概念与术语</h4><ul><li>数据：实质是描述客观事物的符号，是能够被计算机识别并输入给计算机处理的符号集合。</li><li>数据元素（记录）：组成数据的具有一定意义的基本单位。</li><li>数据项：组成数据元素的最小单位，一个数据可由若干个数据项组成。</li><li>数据对象：由性质相同数据元素组成的集合，为数据的子集。</li><li>数据结构：相互之间存在一种或多种特定关系的数据元素的集合。<blockquote><p>结构：实质上可以理解为各组成部分相互搭配和排列的方式。</p></blockquote></li></ul><hr><h4 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h4><p>一，逻辑结构</p><blockquote><p>数据对象中数据元素之间的相互关系。（该结构是面向实际问题而言） </p></blockquote><ul><li>集合结构：集合结构中数据元素除了同属于一个集合外无其他关系。<br><img src="http://q7u2d5quo.bkt.clouddn.com/algorithms/20200331/3WXdWDDrr7iM.png" alt="集合结构"></li><li>线性结构：线性结构中数据元素为一对一的关系。<br><img src="http://q7u2d5quo.bkt.clouddn.com/algorithms/20200331/vxaBL9ADRdQh.png" alt="线性结构"></li><li>树形结构：树形结构中数据元素存在一对多的关系。<br><img src="http://q7u2d5quo.bkt.clouddn.com/algorithms/20200331/l867Jj40GRj7.png" alt="树形结构"></li><li>图形结构：图形结构中数据元素存在多对多的关系。<br><img src="http://q7u2d5quo.bkt.clouddn.com/algorithms/20200331/CRkIf1O6zcSN.png" alt="图形结构"><br>二，物理结构<blockquote><p>数据的逻辑结构在计算机中的存储方式。</p></blockquote></li><li>顺序存储结构：将数据元素存放到练习的存储单元中。（如线性表）<br><img src="http://q7u2d5quo.bkt.clouddn.com/algorithms/20200331/OXR4LYWv0p0X.png" alt="顺序存储"></li><li>链式存储结构：将数据元素存放在任意的存储单元中，该组存储单元可以连续也可以是非连续的。<blockquote><p>通过指针指向下一个存储单元，从而找到相应元素的位置。</p></blockquote></li></ul><p><img src="http://q7u2d5quo.bkt.clouddn.com/algorithms/20200331/uqiUM6irG5Q9.png" alt="链式存储"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;if you give someone a program you will frustrate him for 
      
    
    </summary>
    
    
    
      <category term="Algorithms" scheme="https://github.com/keviness/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>CSS Layout 之三栏布局实现</title>
    <link href="https://github.com/keviness/2020/03/18/CSS/CSS_Layout2/"/>
    <id>https://github.com/keviness/2020/03/18/CSS/CSS_Layout2/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2020-03-22T13:41:42.475Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现三栏布局（网页宽度自适应）"><a href="#实现三栏布局（网页宽度自适应）" class="headerlink" title="实现三栏布局（网页宽度自适应）"></a>实现三栏布局（网页宽度自适应）</h3><h4 id="一，absolute绝对定位法（main置于中间）"><a href="#一，absolute绝对定位法（main置于中间）" class="headerlink" title="一，absolute绝对定位法（main置于中间）"></a>一，absolute绝对定位法（main置于中间）</h4><p>HTML代码:</p><pre><code>&lt;body&gt;    &lt;div id=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><hr><p>CSS:</p><pre><code>#left, #right{    position:absolute;    top:0;    height:100%;    width:200px;}#left{    left:0;}#right{    right:0;}#main{    margin: 210px;}</code></pre><hr><h4 id="magrin负值法（negative-margin）"><a href="#magrin负值法（negative-margin）" class="headerlink" title="magrin负值法（negative margin）"></a>magrin负值法（negative margin）</h4><p>HTML代码：main要用双重嵌套标签。</p><pre><code>&lt;body&gt;    &lt;div id=&quot;main&quot;&gt;        &lt;div id=&quot;body&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><hr><p>CSS:</p><pre><code>#main{    width:100%;    height:100%;    float:left;}#main #body{    margin:0 210px;    height:100%;}#left, #right{    width:200px;    height:100px;    float:float;}#left{    margin-left: -100%;}#right{    margin-right: -200px;}</code></pre><hr><h4 id="float自身浮动法"><a href="#float自身浮动法" class="headerlink" title="float自身浮动法"></a>float自身浮动法</h4><p>HTML代码：main放于最后。</p><pre><code>&lt;body&gt;    &lt;div id=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><hr><p>CSS：</p><pre><code>#main{    height:100%;    margin:0 210px;}#left, #right{    right:100%;    width:200px;}#left{    float:left;}#right{    float:right;}</code></pre><hr><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>HTML代码：</p><pre><code>&lt;body&gt;    &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;sub&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;extra&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><hr><h5 id="法一-（类似方案三）"><a href="#法一-（类似方案三）" class="headerlink" title="法一:（类似方案三）"></a>法一:（类似方案三）</h5><p>HTML代码：不变。</p><hr><p>CSS：</p><pre><code>body{    padding:0 230px 0 190px;}#main{    float:left;    width:100%;}#sub{    float:left;    margin-left:-100%;    width:190px;    position:relative;    left:-190px;}#extra{    float:left;    margin-left:-230px;    width:230px;    position:relative;    right:-230px;}</code></pre><hr><h5 id="法二：在main元素外加一层包装元素。"><a href="#法二：在main元素外加一层包装元素。" class="headerlink" title="法二：在main元素外加一层包装元素。"></a>法二：在main元素外加一层包装元素。</h5><p>HTML代码：id=”main”元素外加一个盒子，封装为id=”main-content”</p><pre><code>&lt;div id=&quot;main-content&quot;&gt;    &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><hr><p>CSS：</p><pre><code>#main{    float:left;    width:100%;}#main-content{    margin:0 230px 0 190px;}#sub{    float:left;    margin-left:-100%;    width:190px;}#extra{    float:left;    margin-left:-230px;    width:230px;}</code></pre><hr><h5 id="法三：对main用padding。"><a href="#法三：对main用padding。" class="headerlink" title="法三：对main用padding。"></a>法三：对main用padding。</h5><p>HTML代码：不变。</p><hr><p>CSS：</p><pre><code>#main{    float:left;    width:100%;    box-sizing:border-box;    padding:0 210px 0 190px;}#sub{    float:left;    margin-left:-100%;    width:190px;}#extra{    float:left;    margin-left:-230px;    width:230px;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现三栏布局（网页宽度自适应）&quot;&gt;&lt;a href=&quot;#实现三栏布局（网页宽度自适应）&quot; class=&quot;headerlink&quot; title=&quot;实现三栏布局（网页宽度自适应）&quot;&gt;&lt;/a&gt;实现三栏布局（网页宽度自适应）&lt;/h3&gt;&lt;h4 id=&quot;一，absolute绝对定
      
    
    </summary>
    
    
    
      <category term="CSS layout" scheme="https://github.com/keviness/tags/CSS-layout/"/>
    
  </entry>
  
  <entry>
    <title>CSS Layout 之两栏布局实现</title>
    <link href="https://github.com/keviness/2020/03/17/CSS/CSS_Layout1/"/>
    <id>https://github.com/keviness/2020/03/17/CSS/CSS_Layout1/</id>
    <published>2020-03-16T16:00:00.000Z</published>
    <updated>2020-03-25T13:41:21.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现两栏布局的方法（左侧固定右侧自适应）"><a href="#实现两栏布局的方法（左侧固定右侧自适应）" class="headerlink" title="实现两栏布局的方法（左侧固定右侧自适应）"></a>实现两栏布局的方法（左侧固定右侧自适应）</h3><pre><code>&lt;div class=&quot;wrap&quot;&gt;&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;right&lt;/right&gt;&lt;/div&gt;</code></pre><h4 id="一，双inline-block方案"><a href="#一，双inline-block方案" class="headerlink" title="一，双inline-block方案"></a>一，双inline-block方案</h4><pre><code>.wrap{font-size:0}.left, .right{    display:inline-block;    vertical-align:top;    font-size:14px;    box-sizing:border-box;}.right{width:calc(100%-140px)}</code></pre><h4 id="二，双float方案"><a href="#二，双float方案" class="headerlink" title="二，双float方案"></a>二，双float方案</h4><pre><code>.wrap{overflow:auto;    box-sizing:content-box;}.left, .right{    float:left;    box-sizing:border-box;}.right{    width:calc(100%-140px);}</code></pre><h4 id="三，float-margin-left方案"><a href="#三，float-margin-left方案" class="headerlink" title="三，float + margin-left方案"></a>三，float + margin-left方案</h4><pre><code>.wrap{overflow:hidden;}.left{float:left;}.right{margin-left:150px;}</code></pre><h4 id="四，absolute-margin-left方案"><a href="#四，absolute-margin-left方案" class="headerlink" title="四，absolute + margin-left方案"></a>四，absolute + margin-left方案</h4><pre><code>.left{position:absolute;}.right{margin-left:150px;}</code></pre><h4 id="五，float-BFC方案"><a href="#五，float-BFC方案" class="headerlink" title="五，float + BFC方案"></a>五，float + BFC方案</h4><pre><code>.wrap{overflow:auto;}.left{    float:left;    margin-left:20px;}.right{    margin-left:0;    overflow:auto; //形成BFC}</code></pre><h4 id="六，flex方案"><a href="#六，flex方案" class="headerlink" title="六，flex方案"></a>六，flex方案</h4><pre><code>.wrap{    display:flex;    align-items:flex-start;}.left{flex:0 0 auto}.right{flex:1 1 auto}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现两栏布局的方法（左侧固定右侧自适应）&quot;&gt;&lt;a href=&quot;#实现两栏布局的方法（左侧固定右侧自适应）&quot; class=&quot;headerlink&quot; title=&quot;实现两栏布局的方法（左侧固定右侧自适应）&quot;&gt;&lt;/a&gt;实现两栏布局的方法（左侧固定右侧自适应）&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="CSS Layout" scheme="https://github.com/keviness/tags/CSS-Layout/"/>
    
  </entry>
  
  <entry>
    <title>CSS Flex</title>
    <link href="https://github.com/keviness/2020/03/16/CSS/CSS_Flex/"/>
    <id>https://github.com/keviness/2020/03/16/CSS/CSS_Flex/</id>
    <published>2020-03-15T16:00:00.000Z</published>
    <updated>2020-04-26T07:17:21.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-Flex"><a href="#CSS-Flex" class="headerlink" title="CSS Flex"></a>CSS Flex</h2><blockquote><p>Flexible Box</p></blockquote><h3 id="Flex示意图"><a href="#Flex示意图" class="headerlink" title="Flex示意图"></a>Flex示意图</h3><img src="/2020/03/16/CSS/CSS_Flex/CSSFlex.png" class title="CSS flex"><h4 id="1，任何容器都可指定为flex布局-webkit内核浏览器应加前缀-webkit"><a href="#1，任何容器都可指定为flex布局-webkit内核浏览器应加前缀-webkit" class="headerlink" title="1，任何容器都可指定为flex布局(webkit内核浏览器应加前缀-webkit)"></a>1，任何容器都可指定为flex布局(webkit内核浏览器应加前缀-webkit)</h4><pre><code>.block_box{display:flex}.inline_box{display:inline-flex}</code></pre><h4 id="2，flex布局之后：子元素float-clear-vertical-align将失效。"><a href="#2，flex布局之后：子元素float-clear-vertical-align将失效。" class="headerlink" title="2，flex布局之后：子元素float,clear,vertical-align将失效。"></a>2，flex布局之后：子元素float,clear,vertical-align将失效。</h4><hr><h3 id="一，容器属性"><a href="#一，容器属性" class="headerlink" title="一，容器属性"></a>一，容器属性</h3><h4 id="1，容器内项目排列属性"><a href="#1，容器内项目排列属性" class="headerlink" title="1，容器内项目排列属性"></a>1，容器内项目排列属性</h4><pre><code>flex-direction: row(default) | row-recerse |colum | colum-reverseflex-wrap: nowrap | wrap | wrap-reverseflex-flow: flex-direction || flex-wrap</code></pre><h4 id="2，容器内项目在主轴对齐方式"><a href="#2，容器内项目在主轴对齐方式" class="headerlink" title="2，容器内项目在主轴对齐方式"></a>2，容器内项目在主轴对齐方式</h4><pre><code>justify-content: flex-start | flex-end | center | space-around | space-between</code></pre><h4 id="3，容器内项目在交叉轴的对齐方式"><a href="#3，容器内项目在交叉轴的对齐方式" class="headerlink" title="3，容器内项目在交叉轴的对齐方式"></a>3，容器内项目在交叉轴的对齐方式</h4><pre><code>align-items: flex-start | flex-end | baseline | stretch</code></pre><h4 id="4，定义多样轴线对齐方式"><a href="#4，定义多样轴线对齐方式" class="headerlink" title="4，定义多样轴线对齐方式"></a>4，定义多样轴线对齐方式</h4><pre><code>align-content: flex-start | flex-end | center | stretch | space-between | space-around</code></pre><h3 id="二，项目属性"><a href="#二，项目属性" class="headerlink" title="二，项目属性"></a>二，项目属性</h3><ul><li><p>ord: 定义排列顺序</p><blockquote><p>.item{ord:integer}</p></blockquote></li><li><p>flex-grow：定义放大比例（default:0）</p><blockquote><p>.item{flex-grow:integer}</p></blockquote></li><li><p>flex-shrink：定义缩小比例（default:1）</p><blockquote><p>.item{flex-shrink:integer}</p></blockquote></li><li><p>flex-basis：定义项目占据主轴空间</p><blockquote><p>.item{flex-basis:integer | auto}</p></blockquote></li><li><p>flex：混合定义</p><blockquote><p>.item{flex: flex-grow | flex-shrink | flex-basis}</p></blockquote><h3 id="三，align-self"><a href="#三，align-self" class="headerlink" title="三，align-self"></a>三，align-self</h3><p>允许单个项目与其他项目相比有不一样的对齐方式</p><blockquote><p>与align-items属性相似，如无父元素，等同于stretch</p></blockquote><p>  align-self: auto | flex-start | flex-end | flex-center | baseline | stretch</p></li></ul><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰：Flex布局教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS-Flex&quot;&gt;&lt;a href=&quot;#CSS-Flex&quot; class=&quot;headerlink&quot; title=&quot;CSS Flex&quot;&gt;&lt;/a&gt;CSS Flex&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Flexible Box&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
    
      <category term="CSS Flex" scheme="https://github.com/keviness/tags/CSS-Flex/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Event</title>
    <link href="https://github.com/keviness/2020/03/15/JavaScript/javascript_event/"/>
    <id>https://github.com/keviness/2020/03/15/JavaScript/javascript_event/</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2020-04-26T07:09:20.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h2><h3 id="JavaScript-Event-示意图"><a href="#JavaScript-Event-示意图" class="headerlink" title="JavaScript Event 示意图"></a>JavaScript Event 示意图</h3><img src="/2020/03/15/JavaScript/javascript_event/javascript_event.png" class title="javascript event"><h4 id="事件流：描述从页面接收事件的次序"><a href="#事件流：描述从页面接收事件的次序" class="headerlink" title="事件流：描述从页面接收事件的次序"></a>事件流：描述从页面接收事件的次序</h4><ul><li><p>事件冒泡（event bubbling）</p><blockquote><p>由嵌套层次最深节点元素（具体事件发生元素）接收，然后向上级元素传播到不具体元素。</p></blockquote></li><li><p>事件捕获（event capturing）</p><blockquote><p>由不具体元素到具体元素传播。</p></blockquote><h4 id="事件处理程序：事件发生后响应的处理函数（方法）"><a href="#事件处理程序：事件发生后响应的处理函数（方法）" class="headerlink" title="事件处理程序：事件发生后响应的处理函数（方法）"></a>事件处理程序：事件发生后响应的处理函数（方法）</h4></li><li><p>HTML事件处理程序</p><blockquote><p>在HTML文档内部为指定元素赋予事件处理程序。<br>例如：在input元素中直接调用事件处理程序。</p></blockquote></li><li><p>DOM0级事件处理程序</p><blockquote><p>在script tag中为元素节点绑定事件处理程序</p></blockquote><p>  element.onclick = function(){statements;}</p></li><li><p>DOM2级事件处理程序</p><blockquote><p>应用事件监听程序为元素节点绑定事件处理程序。</p></blockquote><p>  element.addEventListener(“click”, function,usecapture)</p></li></ul><h4 id="事件委托（事件代理）"><a href="#事件委托（事件代理）" class="headerlink" title="事件委托（事件代理）"></a>事件委托（事件代理）</h4><blockquote><p>利用事件冒泡，只指定一个事件处理程序，可管理某一类型的所有事件。<br>事件代理可有效减少对DOM文档的操作，在父元素中统一执行子元素中某一类型的事件，可大大优化运行性能。</p></blockquote><ul><li>举例<blockquote><p>页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript事件&quot;&gt;&lt;a href=&quot;#JavaScript事件&quot; class=&quot;headerlink&quot; title=&quot;JavaScript事件&quot;&gt;&lt;/a&gt;JavaScript事件&lt;/h2&gt;&lt;h3 id=&quot;JavaScript-Event-示意图&quot;&gt;&lt;a 
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://github.com/keviness/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM</title>
    <link href="https://github.com/keviness/2020/03/14/JavaScript/javascript_DOM/"/>
    <id>https://github.com/keviness/2020/03/14/JavaScript/javascript_DOM/</id>
    <published>2020-03-13T16:00:00.000Z</published>
    <updated>2020-04-02T14:55:11.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-DOM"><a href="#JavaScript-DOM" class="headerlink" title="JavaScript DOM"></a>JavaScript DOM</h2><blockquote><p>DOM Document Object Model</p></blockquote><ul><li><p>DOM是JavaScript核心模型之一，它也是DOMcore的重要表现之一。</p></li><li><p>DOM实质应用表现为一个DOM节点树，除html根元素之外，都有父元素，且每个元素仅有一个父元素。</p><h3 id="DOM重要点："><a href="#DOM重要点：" class="headerlink" title="DOM重要点："></a>DOM重要点：</h3><h4 id="访问节点树"><a href="#访问节点树" class="headerlink" title="访问节点树"></a>访问节点树</h4><p>  object.getElementById()<br>  object.getElementsByClassName()<br>  object.getElementsByTagName()<br>  object.getElementsByName()</p></li></ul><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><pre><code>document.createElement()document.createTextNode()object.appendChild()object.insertBefore()object.removeChild()object.cloneNode(true/false)object.replace(newNode, oldNode)</code></pre><hr><h4 id="操作节点属性"><a href="#操作节点属性" class="headerlink" title="操作节点属性"></a>操作节点属性</h4><h5 id="位置信息"><a href="#位置信息" class="headerlink" title="位置信息"></a>位置信息</h5><pre><code>parentNode  childNodefirstNode   lastNodepreviousSibling     nextSibling</code></pre><h5 id="节点属性信息"><a href="#节点属性信息" class="headerlink" title="节点属性信息"></a>节点属性信息</h5><pre><code>attributesnodeTypenodeNamenodeValueinnerHTMLinnerText</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-DOM&quot;&gt;&lt;a href=&quot;#JavaScript-DOM&quot; class=&quot;headerlink&quot; title=&quot;JavaScript DOM&quot;&gt;&lt;/a&gt;JavaScript DOM&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;DOM Docum
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://github.com/keviness/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>文档流与BFC感悟</title>
    <link href="https://github.com/keviness/2020/02/14/CSS/CSSNote/"/>
    <id>https://github.com/keviness/2020/02/14/CSS/CSSNote/</id>
    <published>2020-02-13T16:00:00.000Z</published>
    <updated>2020-03-22T13:41:19.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><blockquote><p>normal flow 正常文档流<br>position: absolute/fix/relative; z-index; float形成脱离文档流 </p></blockquote><ol><li>文档流包括正常文档流，脱离文档流。</li><li>浮动元素具有破坏性，包裹性及浮动性。会造成父元素高度塌陷，但可以形成文字环绕的效果，应合理应用float元素。</li><li>元素浮动后，块级元素将忽略他的存在，BFC将重新感知它的存在。</li><li>block级元素具有流体性质，会自动填满父级元素，可利用该性质，在布局上形成自适应宽度的效果。</li></ol><hr><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><blockquote><p>Block Format Context 块级元素格式上下文</p></blockquote><ol><li>简单来说，块级元素形成BFC后，会在内部形成一个独立渲染区域，不管外部元素如何进行渲染，BFC总是“泰山崩于前而不改其色”。</li><li>在浮动图片与块级元素（文字）同一布局时，文字形成环绕，可将块级文字用overflow:hidden;形成BFC独立渲染区域，文字将不再环绕图片。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文档流&quot;&gt;&lt;a href=&quot;#文档流&quot; class=&quot;headerlink&quot; title=&quot;文档流&quot;&gt;&lt;/a&gt;文档流&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;normal flow 正常文档流&lt;br&gt;position: absolute/fix/relative;
      
    
    </summary>
    
    
    
      <category term="CSS BFC" scheme="https://github.com/keviness/tags/CSS-BFC/"/>
    
  </entry>
  
  <entry>
    <title>HTMLNote</title>
    <link href="https://github.com/keviness/2020/02/11/HtmlNote/HtmlNote/"/>
    <id>https://github.com/keviness/2020/02/11/HtmlNote/HtmlNote/</id>
    <published>2020-02-10T16:00:00.000Z</published>
    <updated>2020-04-26T07:10:42.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Html5基本结构元素"><a href="#Html5基本结构元素" class="headerlink" title="Html5基本结构元素"></a>Html5基本结构元素</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;   //this is root node&lt;head&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  //this is body node    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h2><ol><li><blockquote><p>HTML日常使用的结构标签并不多，但结构语义化是html文档的灵魂所在，在使用标签时应特别注意。</p></blockquote></li><li><blockquote><p>结构语义化：通俗而言，就是让HTML文档标签标注合适的内容，如p代表文本段落，header代表页首，footer代表页尾等。</p></blockquote></li><li><blockquote><p>结构语义化，有便于HTML文档维护，XHTML在谨慎应用标签方面值得借鉴。</p></blockquote><h2 id="CSS基础内容概要"><a href="#CSS基础内容概要" class="headerlink" title="CSS基础内容概要"></a>CSS基础内容概要</h2></li></ol><hr><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><h4 id="CSS基本选择器"><a href="#CSS基本选择器" class="headerlink" title="CSS基本选择器"></a>CSS基本选择器</h4><ol><li>元素选择器</li><li>ID选择器</li><li>Class选择器<h4 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h4><blockquote><p>根据元素层次关系选择元素</p></blockquote></li><li>父子选择器   M N</li><li>后代选择器   M &gt; N</li><li>兄弟选择器   M ~ N</li><li>相邻选择器   M + N</li></ol><hr><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing:"></a>box-sizing:</h3><ol><li>content box<img src="/2020/02/11/HtmlNote/HtmlNote/boxmodel.jpg" class title="box model"></li><li>border box<br><img src="http://q7u2d5quo.bkt.clouddn.com/algorithms/20200407/wsouhYHgo5fb.jpg" alt="border box"></li><li>padding box<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2></li><li>字体样式</li><li>文本样式</li><li>背景样式</li><li>列表样式</li><li>表格样式</li><li>表单样式</li><li>超链接样式</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Html5基本结构元素&quot;&gt;&lt;a href=&quot;#Html5基本结构元素&quot; class=&quot;headerlink&quot; title=&quot;Html5基本结构元素&quot;&gt;&lt;/a&gt;Html5基本结构元素&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;
      
    
    </summary>
    
    
    
      <category term="HTML" scheme="https://github.com/keviness/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>First Step</title>
    <link href="https://github.com/keviness/2020/02/09/HtmlNote/First-post/"/>
    <id>https://github.com/keviness/2020/02/09/HtmlNote/First-post/</id>
    <published>2020-02-09T09:05:41.000Z</published>
    <updated>2020-03-19T03:40:55.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hello-program-world"><a href="#Hello-program-world" class="headerlink" title="Hello program world"></a>Hello program world</h3><p>本博客会长期更新，记录我的编程历程，学习心得。<br>漫漫长途，心向远方~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hello-program-world&quot;&gt;&lt;a href=&quot;#Hello-program-world&quot; class=&quot;headerlink&quot; title=&quot;Hello program world&quot;&gt;&lt;/a&gt;Hello program world&lt;/h3&gt;&lt;p&gt;本博
      
    
    </summary>
    
    
    
      <category term="记录" scheme="https://github.com/keviness/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
